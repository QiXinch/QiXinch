{"meta":{"title":"QiXin","subtitle":"日拱一卒,功不唐捐","description":"c++/c, linux, hpc, compiler, debug","author":"QiXin","url":"https://QiXinch.github.io/QiXinch","root":"/QiXinch/"},"pages":[],"posts":[{"title":"The difference between delete and delete []","slug":"The-difference-between-delete-and-delete","date":"2023-10-11T08:53:35.000Z","updated":"2023-10-11T08:55:10.765Z","comments":true,"path":"2023/10/11/The-difference-between-delete-and-delete/","link":"","permalink":"https://qixinch.github.io/QiXinch/2023/10/11/The-difference-between-delete-and-delete/","excerpt":"","text":"Motivation在c++中，delete和delete []都和内存释放有关，其中delete用来释放由new申请的单个元素, delete []用来释放由new T[]申请的数组. 在正常使用的情况下, 并不会产生什么问题. 但是在使用new T[]申请后, 使用delete释放的情况下程序可能会出错, 也可能不会出错, 仅凭上面的用法无法解释原因, 所以更深入地探究一下delete和delete []到底做了什么. 12345编译器: gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-13)系统: CentOS Linux release 8.3.2011平台: AMD EPYC 7402 24-Core Processor Test现在有两份源码Test1.cpp和Test2.cpp, 分别编译运行，运行结果如下 12345678910111213141516171819202122232425262728293031323334//Test1.cpp#include &lt;iostream&gt;class Test&#123; public: int t; Test() &#123; std::cout &lt;&lt; &quot;Test()&quot; &lt;&lt; std::endl; &#125;&#125;;int main()&#123; Test *t = new Test[3]; delete t;&#125;//Test2.cpp#include &lt;iostream&gt;class Test&#123; public: int t; Test() &#123; std::cout &lt;&lt; &quot;Test()&quot; &lt;&lt; std::endl; &#125; ~Test() &#123; std::cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; std::endl; &#125;&#125;;int main()&#123; Test *t = new Test[3]; delete t; return 0;&#125; 123456789101112#Test1Test()Test()Test()#Test2Test()Test()Test()~Test()munmap_chunk(): invalid pointerAborted (core dumped) 可以看到，两份源码的唯一区别就是Test2.cpp中的Test定义了析构函数，从而导致Test2运行时出现了coredump, 此外析构函数的class, 内置类型(如int, double), 使用new T[]申请, 使用delete释放时也不会出错. 观察出错的输出, 看到munmap_chunk()就知道是ptmalloc的内存释放出错了, free时传入的指针和申请时传入的指针不相同, 但是仅从源码的角度看是无法解决这个问题了, 所以只能从生成的汇编来进行分析了. Analysis在分析delete和delete []的行为之前, 首先来看new和new T[], 因为delete和delete [], new和new T[]是配合使用的,了解 new和new T[]做了什么才能更好地理解delete和delete[]的行为. new and new T[]首先简单分析一下new需要做什么，根据new的语义，它需要做两件事情: 1. 申请内存，2. 调用构造函数(对于内置类型以及没有显式构造函数的class来说可以不用). 当然这两件事情是有先后顺序的，肯定是1先做(做完之后会得到一个指针，这个指针可以近似看作this指针，因为编译器可能会多申请一些空间来记录一些信息)，2再做。 再来看new T[]，它的语义是申请一个数组，和new类似，它同样是做两件事情，不过在2中，它需要对数组中的每个元素调用构造函数. 分析了new和new T[]，那么delete和delete []要做的也就是以相反的顺序来执行对应的行为. 但是仔细分析的话会发现一个问题: 在使用new T[]时，我们传入了一个参数来指定申请的元素个数， 但是使用delete []时却并没有指定需要释放的元素个数 这和malloc和free的情况类似，如果对malloc和free有所了解的话那么大概就能想到一种解决方法(:wink:). 那就是在申请空间的时候多申请一些空间来存储申请的个数，保证偏移是固定的，然后释放时再把偏移还原回去. 那么就让我们来验证一下. 下面的输出选自汇编文件(删除了一些编译器生成的信息，增加了一些注释)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Test1.s47 main: 48 .LFB1521: 52 pushq %rbp 55 movq %rsp, %rbp 57 pushq %r13 58 pushq %r12 59 pushq %rbx 60 subq $24, %rsp //Test *t = new Test[3]被翻译成两部分 //1. t = malloc(12) // 12 = sizeof(Test) * 3 64 movl $12, %edi 65 .LEHB0: 66 call _Znam 67 .LEHE0: 68 movq %rax, %rbx 69 movq %rbx, %r13 70 movl $2, %r12d //2. .L4-.L3分别对t[0], t[1], t[2]调用构造函数 // Test(t); // Test(t + 1); // Test(t + 1); 71 .L4: 72 testq %r12, %r12 73 js .L3 74 movq %r13, %rdi 75 .LEHB1: 76 call _ZN4TestC1Ev 77 .LEHE1: 78 addq $4, %r13 79 subq $1, %r12 80 jmp .L4 81 .L3: //下面对应于 delete t; //delete t =&gt; call operator delete(t, 4) =&gt; free(t) 82 movq %rbx, -40(%rbp) 83 movq -40(%rbp), %rax 84 movl $4, %esi 85 movq %rax, %rdi 86 call _ZdlPvm //################# operator delete(void*, unsigned long) #################//Test2.s 88 main: 89 .LFB1524: 93 pushq %rbp 96 movq %rsp, %rbp 98 pushq %r14 99 pushq %r13100 pushq %r12101 pushq %rbx102 subq $16, %rsp //和Test1相同，但是申请的空间大小为20 = sizeof(Test) * 3 + 8 //char *t0 = malloc(20)107 movl $20, %edi108 .LEHB0:109 call _Znam //首先使用8个bytes存储申请数组的大小 //*((unsigned long*)(t0)) = 3110 .LEHE0:111 movq %rax, %r13112 movq $3, 0(%r13)113 leaq 8(%r13), %rbx114 movl $2, %r12d115 movq %rbx, %r14 //申请的指针+8之后是我们得到的指针，也就是t //Test *t = (Test*)(((char*)(t0)) + 8) //.L5-.L4对t[0], t[1], t[2]调用构造函数116 .L5:117 testq %r12, %r12118 js .L4119 movq %r14, %rdi120 .LEHB1:121 call _ZN4TestC1Ev122 .LEHE1:123 addq $4, %r14124 subq $1, %r12125 jmp .L5126 .L4: //.L4只对t[0]调用析构函数127 leaq 8(%r13), %rax128 movq %rax, -40(%rbp)129 movq -40(%rbp), %rbx130 testq %rbx, %rbx131 je .L6132 movq %rbx, %rdi133 call _ZN4TestD1Ev //这里delete的指针是t，而编译器申请的指针是t0，所以free的时候会出错134 movl $4, %esi135 movq %rbx, %rdi136 call _ZdlPvm //################# operator delete(void*, unsigned long) ################# 137 .L6:138 movl $0, %eax139 jmp .L12 分析这两份汇编代码可以看到 在Test1中申请的空间大小为12 bytes(line 64)，在释放时没有调用析构函数，在调用operator delete(void*, unsigned long)时传入的第一个参数是new得到的参数， 第二个参数是4(line 84,85,86). 在Test2中申请的空间大小为20 bytes(line 107)，在释放时调用了析构函数(line 133)，在调用operator delete(void*, unsigned long)时传入的参数是new得到的参数+8(line 127). 所以，问题在于编译器多申请了一些空间，但是在释放时却需要程序员来告诉编译器需要释放多申请的空间，否则就会出错:sweat:示意图如下： Conclusion 对于带有析构函数的class来说，在释放时需要调用析构函数，而对于编译器合成析构函数的class来说，只需要简单地释放内存. 在申请数组时，对于有析构函数的class来说，需要多余的空间来存放申请的数组的数目，这样才能知道到底需要执行多少次析构函数，new T[]返回的指针为实际申请返回的指针值+8(Test1申请了12 bytes，Test2申请了20 bytes)，而对于普通的class来说并不需要执行析构函数，因此申请的空间只是数组需要的空间. 使用new T[]申请空间，使用delete释放时，释放的指针并不是申请时返回的指针，因此报错. 可以看到编译器将delete翻译成了对operator delete(void*, unsigned long)的调用，然后再底层的应该是对free的调用，而且现在只需要释放空间，这样的话第二个参数是多余的，将第二个参数任意修改，发现并不影响执行结果. Last这篇文章只是对代码进行分析，使用具体的例子来看new和new T[]和delete和delete[]的行为，对于程序错误进行分析，可以大致了解一下delete和delete []的不同以及实现的差异. 但是对于delete和delete []，new和new T[]的具体语义并没有查询c++标准，因此可能存在一些错误，并且分析的情况并不到位，甚至于和编译器版本和实现有关系。仅供参考","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-10-03T14:10:31.938Z","updated":"2023-10-03T14:10:31.938Z","comments":true,"path":"2023/10/03/hello-world/","link":"","permalink":"https://qixinch.github.io/QiXinch/2023/10/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}